[
{
	"uri": "https://wails.app/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Wails is a framework to help write desktop apps using Go and Web Technologies. For the frontend, it uses the Webview library. This in turn uses the native rendering engine for the platform (currently Webkit for Linux \u0026amp; Mac, MSHTML for Windows). The frontend is coded using HTML/Javascript/CSS and the backend is pure Go. It is possible to expose Go code to the frontend, as functions that return promises, through a binding mechanism. The project compiles down to a single executable, bundling all assets into it. On Windows and MacOS, it is possible to bundle the binary into the platform-specific package for distribution.\n"
},
{
	"uri": "https://wails.app/gettingstarted/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Please select your Operating System\n  Mac  Linux  Windows  "
},
{
	"uri": "https://wails.app/gettingstarted/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": " There are many Linux distributions in existence and we strive to support as many as possible.\nOficially supported distros:    Distro Version     Debian 8, 9, 10   Ubuntu 16.04, 18,04, 19.04   Arch Rolling   CentOS 6, 7   Fedora 29, 30    Community supported distros:    Distro Version     Zorin 15   Parrot 4.7   Mint 19   Elementary 5   Kali Rolling   Neon 5.16   VoidLinux \u0026amp; VoidLinux-musl Rolling   Gentoo Rolling    If you don\u0026rsquo;t see your distro in the lists bellow you have two options. Either open a ticket asking for support or if you feel adventurus follow the guide how to add support for your linux distro and also consider making a PR so the community can benefit.\nPrerequisites Wails uses cgo to bind to the native rendering engines so a number of platform dependent libraries are needed as well as an installation of Go. The basic requirements are:\n Go 1.12 or above npm gcc, gtk, webkitgtk  Go Download Go either using your system package manager or from the Go Downloads Page.\nEnsure that you follow the official Go installation instructions.\nAdd $GOPATH/bin to the PATH and on to the GO111MODULE environment variables. You can do this by adding these lines to your /etc/profile (for a system-wide installation) or $HOME/.profile:\nexport PATH=$PATH:$GOPATH/bin export GO111MODULE=on Note: changes made to a profile file may not apply until the next time you log into your computer. To apply the changes immediately, just run the shell commands directly or execute them from the profile using a command such as source $HOME/.profile.\n npm Download npm either using your system package manager or from the Node Downloads Page. It is best to use the latest release as that is what we generally test against.\nRun npm --version to verify.\ngcc, gtk, webkit For Linux, Wails uses gcc, webkit and GTK. These need to be installed using the distribution specific commands below.\nDebian/Ubuntu \u0026amp; derivatives sudo apt install build-essential libgtk-3-dev libwebkit2gtk-4.0-dev\nArch Linux \u0026amp; derivatives sudo pacman -S gcc pkgconf webkit2gtk gtk3\nCentos sudo yum install gcc-c++ make pkgconf-pkg-config webkitgtk3-devel gtk3-devel\nFedora sudo yum install gcc-c++ make pkgconf-pkg-config webkit2gtk3-devel gtk3-devel\nVoidLinux \u0026amp; VoidLinux-musl xbps-install base-devel gtk+3-devel webkit2gtk-devel\nGentoo sudo emerge gtk+:3 webkit-gtk\nIf you have successfully installed these dependencies on a different flavour of Linux, please consider clicking the \u0026ldquo;Edit this page\u0026rdquo; link at the top of the page and submit a PR.\n Now you are ready to move on to the next step of installing Wails.\n"
},
{
	"uri": "https://wails.app/gettingstarted/mac/",
	"title": "Mac",
	"tags": [],
	"description": "",
	"content": "Now you are ready to move on to the next step of installing Wails.\n"
},
{
	"uri": "https://wails.app/gettingstarted/windows/",
	"title": "Windows",
	"tags": [],
	"description": "",
	"content": "Now you are ready to move on to the next step of installing Wails.\n"
},
{
	"uri": "https://wails.app/reference/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": " Binding Having just a web frontend means nothing unless you can interact with the system. Wails enables this through \u0026lsquo;binding\u0026rsquo; - making Go code callable from the frontend. There are 2 types of code you can bind to the frontend: Functions and Struct Methods. When they are bound, they may be used in the frontend.\nFunctions Binding a function is as easy as this:\npackage main import ( \u0026#34;github.com/wailsapp/wails\u0026#34; \u0026#34;fmt\u0026#34; ) func Greet(name string) string { return fmt.Printf(\u0026#34;Hello %s!\u0026#34;, name) } func main() { app := wails.CreateApp(\u0026amp;wails.AppConfig{ Width: 1024, Height: 768, }) app.Bind(Greet)  app.Run() } When this is run, a Javascript function called \u0026lsquo;Greet\u0026rsquo; is made available under the global \u0026lsquo;backend\u0026rsquo; object. The function may be invoked by calling backend.Greet, EG: backend.Greet(\u0026quot;World\u0026quot;). The dynamically generated functions return a standard promise. For this simple example, you could therefore print the result as so: backend.Greet(\u0026quot;World\u0026quot;).then(console.log).\nStructs It is possible to bind structs to the frontend in a similar way but we must be clear on what this means: Binding a struct simply means exposing the public methods of the struct to the frontend. Wails does not attempt, or even believe, that binding data to the frontend is a good thing. Wails views the frontend as primarily a view layer with state and business logic normally handled by Go. As such, the structs that you bind to the front end should be viewed as a \u0026ldquo;wrapper\u0026rdquo; or an \u0026ldquo;interface\u0026rdquo;.\nBinding a struct is as easy as:\n robot.go\n package main import \u0026#34;fmt\u0026#34; type Robot struct { Name string } func NewRobot() *Robot { result := \u0026amp;Robot{ Name: \u0026#34;Robbie\u0026#34;, } return result } func (t *Robot) Hello(name string) string { return fmt.Sprintf(\u0026#34;Hello %s! My name is %s\u0026#34;, name, t.Name) } func (t *Robot) Rename(name string) string { t.Name = name return fmt.Sprintf(\u0026#34;My name is now \u0026#39;%s\u0026#39;\u0026#34;, t.Name) } func (t *Robot) privateMethod(name string) string { t.Name = name return fmt.Sprintf(\u0026#34;My name is now \u0026#39;%s\u0026#39;\u0026#34;, t.Name) }  main.go\n package main import \u0026#34;github.com/wailsapp/wails\u0026#34; func main() { app := wails.CreateApp(\u0026amp;wails.AppConfig{ Width: 1024, Height: 768, Title: \u0026#34;Binding Structs\u0026#34;, }) app.Bind(NewRobot()) app.Run() } When the Robot struct is bound, it is made available at backend.Robot in the frontend. As the robot struct has a public method called Hello, then this is available to call at backend.Robot.Hello. The same is true for the Rename method. The robot struct also has another method called privateMethod, but as that is not public, it is not bound.\nHere is a demonstration of how this works by running the app in debug mode and using the inspector:\n Struct Initialisation If your struct has a special initialisation method, Wails will call it at startup. The signature for this method is:\nWailsInit(runtime *wails.Runtime) error This allows you to do some initialisation before the main application is launched.\ntype MyStruct struct { runtime *wails.Runtime } func (s *MyStruct) WailsInit(runtime *wails.Runtime) error { // Save runtime  s.runtime = runtime // Do some other initialisation  return nil } If an error is returned, then the application will log the error and shutdown.\nThe Runtime Object that is passed to it is the primary means for interacting with the application at runtime. It consists of a number of subsystems which provide access to different parts of the system. This is detailed in the Wails Runtime section.\nBinding Rules Any Go function (or method) may be bound, so long as it follows the following rules:\n The function must return 0 - 2 results. If there are 2 return parameters, the last one must be an error type. If you return a struct, or struct pointer, the fields you wish to access in the frontend must have Go\u0026rsquo;s standard json struct tags defined.  If only one value is returned then it will either be available in the resolve or reject part of the promise depending on if it was an error type or not.\nExample 1:\nfunc (m *MyStruct) MyBoundMethod(name string) string { return fmt.Sprintf(\u0026#34;Hello %s!\u0026#34;, name) } In Javascript, the call to MyStruct.MyBoundMethod will return a promise that will resolve with a string.\n Example 2\n ... func (m *MyStruct) AddUser(name string) error { if m.userExists(name) { return fmt.Errorf(\u0026#34;user \u0026#39;%s\u0026#39; already exists\u0026#34;); } m.saveUser(name) return nil } ... In Javascript, the call to MyStruct.MyBoundMethod with a new user name will return a promise that will resolve with no value. A call to MyStruct.MyBoundMethod with an existing user name will return a promise that will reject with the error set to user '$name' already exists.\nIt\u0026rsquo;s good practice to return 2 values, a result and an error, as this maps directly to Javascript promises. If you are not returning anything, then perhaps events may be a better fit.\nImportant Detail! A very important detail to consider is that all calls to bound Go code are run in their own goroutine. Any bound functions should be authored with this in mind. The reason for this is to ensure that bound code does not block the main event loop in the application, which leads to a frozen UI.\n"
},
{
	"uri": "https://wails.app/guides/distro/",
	"title": "Add support for your Linux distro",
	"tags": [],
	"description": "",
	"content": "This guide shows all the necessary steps to use unspported linux distribytion with Wails.\nif you managed to get Wails working for your desktop please consider making a Pull Request\nCli reference\nwails ├── cmd │ ├── cmd-mewn.go │ ├── linuxdb.yaml │ ├── linux.go │ └── system.go └── README.md  "
},
{
	"uri": "https://wails.app/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": " Reference This section goes into detail about the components of the Wails framework\n"
},
{
	"uri": "https://wails.app/reference/runtime/",
	"title": "Runtime",
	"tags": [],
	"description": "",
	"content": " Wails comes with a runtime library that may be accessed from Javascript or Go. It has the following subsystems:\n Events Logging Window Dialog Browser  NOTE: At this time, the Javascript runtime does not include the Window and Dialog subsystems\nWhen binding a struct with the WailsInit method, the Go runtime object is presented by the Application.\nFor the frontend, the runtime is accessed through the window.wails object.\nEvents The Events subsystem provides a means of listening and emitting events across the application as a whole. This means that you can listen for events emitted in both Javascript and Go, and events that you emit will be received by listeners in both Go and Javascript.\nIn the Go runtime, it is accessible via runtime.Events and provides 2 methods: Emit and On.\nEmit  Emit(eventName string, optionalData \u0026hellip;interface{})\n The Emit method is used to emit named events across the application.\nThe first parameter is the name of the event to emit. The second parameter is an optional list of interface{} types, meaning you can pass arbitrary data along with the event.\nExample 1:\nfunc (m *MyStruct) WailsInit(runtime *wails.Runtime) error { runtime.Events.Emit(\u0026#34;initialised\u0026#34;) } Example 2:\nfunc (m *MyStruct) WailsInit(runtime *wails.Runtime) error { t := time.Now() message := fmt.Sprintf(\u0026#34;I was initialised at %s\u0026#34;, t.String()) runtime.Events.Emit(\u0026#34;initialised\u0026#34;, message) } On  On(eventName string, callback func(optionalData \u0026hellip;interface{}))\n The On method is used to listen for events emitted across the application.\nThe first parameter is the name of the event to listen for. The second parameter is a function to call when the event is emitted. This function has an optional parameter which will contain any data that was sent with the event. To listen to the 2 events emitted in the emit examples:\nExample with no data:\nfunc (m *MyStruct) WailsInit(runtime *wails.Runtime) error { runtime.Events.On(\u0026#34;initialised\u0026#34;, func(...interface{}) { fmt.Println(\u0026#34;I received the \u0026#39;initialised\u0026#39; event!\u0026#34;) }) return nil } Example with data:\nfunc (m *MyStruct) WailsInit(runtime *wails.Runtime) error { runtime.Events.On(\u0026#34;hello\u0026#34;, func(data ...interface{}) { // You should probably do better error checking  fmt.Printf(\u0026#34;I received the \u0026#39;initialised\u0026#39; event with the message \u0026#39;%s\u0026#39;!\\n\u0026#34;, data[0]) }) return nil } Log The Log subsystem allows you to log messages at various log levels to the application log.\nNew  New(prefix string)\n Creates a new custom Logger with the given prefix.\ntype MyStruct struct { log *wails.CustomLogger } func (m *MyStruct) WailsInit(runtime *wails.Runtime) error { m.log = runtime.Log.New(\u0026#34;MyStruct\u0026#34;) return nil } Once created, you may use any of the logger\u0026rsquo;s methods:\nStandard logging Each of these methods take a string (like fmt.Println):\n Debug Info Warn Error Fatal\nm.Log.Info(\u0026#34;This is fine\u0026#34;)  Formatted logging Each of these methods take a string and optional data (like fmt.Printf):\n Debugf Infof Warnf Errorf Fatalf\nfeeling := \u0026#34;okay\u0026#34; m.Log.Info(\u0026#34;I\u0026#39;m %s with the events that are currently unfolding\u0026#34;, feeling)  Field logging Each of these methods take a string and a set of fields:\n DebugFields InfoFields WarnFields ErrorFields FatalFields\nm.Log.InfoFields(\u0026#34;That\u0026#39;s okay\u0026#34;, wails.Fields{ \u0026#34;things are going to be\u0026#34;: \u0026#34;okay\u0026#34;, })  Dialog The Dialog subsystem allows you to activate the Webview\u0026rsquo;s native dialogs. It is accessible via runtime.Dialog and has the following methods:\nNOTE: Opening a Dialog will halt Javascript execution, just like a browser\nSelectFile  SelectFile()\n Prompts the user to select a file for opening. Returns the path to the file.\nselectedFile := runtime.Dialog.SelectFile() SelectDirectory  SelectDirectory()\n Prompts the user to select a directory. Returns the path to the directory.\nselectedDirectory := runtime.Dialog.SelectDirectory() SelectSaveFile  SelectSaveFile()\n Prompts the user to select a file for saving. Returns the path to the file.\nselectedFile := runtime.Dialog.SelectSaveFile() Window The Window subsystem provides methods to interact with the application\u0026rsquo;s main window.\nSetColour  SetColour(colour string) error\n Sets the background colour of the window to the colour given to it (string). The colour may be specified in the following formats:\n RGB \u0026ldquo;rgb(0, 0, 0)\u0026rdquo; RGBA \u0026ldquo;rgba(0, 0, 0, 0.8)\u0026rdquo; HEX \u0026ldquo;#fff\u0026rdquo;\nruntime.Window.SetColour(\u0026#34;#eee\u0026#34;)  Fullscreen  Fullscreen()\n Attempts to make the application window fullscreen. Will fail if the application was started with the option \u0026ldquo;Resize: false\u0026rdquo;.\nruntime.Window.Fullscreen() UnFullscreen  UnFullscreen()\n Attempts to revert the window back to its size prior to a Fullscreen call. Will fail if the application was started with the option \u0026ldquo;Resize: false\u0026rdquo;\nUnFullscreen() SetTitle  SetTitle(title string)\n Sets the title in the application title bar.\nruntime.Window.SetTitle(\u0026#34;We\u0026#39;ll need a bigger boat\u0026#34;) Close Closes the main window and thus terminates the application. Use with care!\nruntime.Window.Close() Browser The browser subsystem provides methods to interact with the system browser.\nOpenURL  OpenURL(url string)\n Opens the given URL in the system browser.\nruntime.Browser.OpenURL(\u0026#34;https://wails.app\u0026#34;) A Common Pattern A common pattern for the Runtime is to simply save it as part of the struct and use it when needed:\ntype MyStruct struct { Runtime *wails.Runtime } func (m *MyStruct) WailsInit(r *wails.Runtime) error { m.Runtime = r }"
},
{
	"uri": "https://wails.app/gettingstarted/installing/",
	"title": "Installing Wails",
	"tags": [],
	"description": "",
	"content": " Installation is as simple as running the following command:\ngo get github.com/wailsapp/wails/cmd/wails  Once installed, the wails update command may be used for subsequent updates.\n To get the latest pre-release with bleeding-edge features the -pre flag can be appended wails update -pre.\n Setup To finish the installation setup your Wails system by running the setup command wails setup and filling your handle and email.\nGenerate a new project Generate a new project using the init command wails init.\nSelect the default options.\nBuild it! Change into the project directory cd my-project and compile your application using the build command wails build.\nIf all went well, you should have a compiled program in your local directory. Run it with ./my-project or double click myproject.exe if on windows.\n Serve wails serve While developing your apps using wails the preferred method is by the serve command wails serve.\nThis produces a much faster lightweight build in debug mode, excluding npm build scripts, saving time when developing the backend and also enabling use of npm run serve for partial browser development of frontend!\n npm run serve Change into the frontend directory cd my-project/frontend and serve your GUI using npm run serve.\nNext Steps If you would like to start making an app right away, we suggest you explore Wails via our awesome tutorials. If you would prefer to get to know the framework a little better before building anything, we suggest having a look through the concepts. Finally if you are advanced user and would like to get right in to it head over to the API reference \u0026amp; Cli reference sections.\nCome by our Slack channel (Invite) for 24\u0026frasl;7 support or just to share with us what you\u0026rsquo;ve built with wails!\n "
},
{
	"uri": "https://wails.app/guides/",
	"title": "Guides",
	"tags": [],
	"description": "",
	"content": " Guides \u0026amp; Turorials Guides npm, JS  Events with React JS template Creating new nuxt project  Linux  Add support for your Linux distro Snap your application  Tutorials A collection of in-depth long-form tutorials to help understand how to use Wails to build a desktop app from scratch.\nQuote generator Building on the default template, we create a Quotes Generator. This introduces the concepts of binding a struct to your application as well as interacting with the Wails runtime in Go.\nThis is recommended for those who are proficient in Javascript and Go and are looking to quickly create an app. It builds on the Template Tutorial so it is recommended to complete that first.\nTODO What\u0026rsquo;s a framework without a Todo app? We revisit the classic app, basing it on the Todo MVC version.\nThis is a comprehensive and advanced tutorial that only requires a basic knowledge of Javascript and Go. It covers all aspects of Wails and is recommended for people of all skill levels.\nCPU usage app In Package Main Episode 16, Alex Pliutau builds a CPU Usage app with Wails. He covers struct binding, the events system and how to use 3rd party Javascript packages in your app. It\u0026rsquo;s a really great tutorial!\nThe tutorial is also available in text format at Package Main\u0026rsquo;s episode 16 github repo or as a Medium article.\nFile transfer app (gRPC) "
},
{
	"uri": "https://wails.app/reference/cli/",
	"title": "CLI",
	"tags": [],
	"description": "",
	"content": " Wails comes with a CLI tool that allows you to generate, build and bundle your projects. It deals with the complexity of juggling Go and Javascript environments.\nIt has a number of commands:\nHelp  wails \u0026ndash;help\n This will output the cli help message with all the available commands and flags.\nSetup  wails setup\n The setup command does a number of things - it asks you for your name and email so that it can fill in project templates with your details. It also checks to see if your environment has the dependencies it needs and if not, try to suggest ways on how to install those dependencies.\nSetup is also the default command so it can be invoked by simply running wails.\nYour browser does not support the video tag.   Init  wails init\n The init command builds out a new project based on a template of your choice. We curently support a basic Vue, Vuetify and React templates. The project will be built automatically after initialisation.\nBasic Vue This template consists of a frontend composed of Vue components, bundled together using Webpack. It makes a simple call to the backend.\nVuetify This template consists of a frontend composed of Vuetify components, bundled together using Webpack. It makes a simple call to the backend.\nReact This template consists of a frontend composed of React components, bundled together using Webpack. It makes a simple call to the backend.\nYour browser does not support the video tag.   Serve  wails serve\n When you run wails serve, it will compile up the backend and run it in headless mode. This allows you to develop the frontend using your standard tooling. When you run your app, it will connect to the backend at startup and make all your backend functions available to you.\nWe will cover this more in the tutorial.\nYour browser does not support the video tag.   Build  wails build\n The build command is the Wails equivalent of go build, however it does a number of things:\n Installs frontend dependencies if needed Performs a build of the frontend Packs the frontend using Webpack It downloads any Go dependencies that are required It finally compiles and bundles everything into a single binary  Your browser does not support the video tag.   Build Flags Here is a list of all available flags:\n   Flag Description     -f Force rebuild of frontend dependencies   -d Build application in Debug mode   -p Package application after a successful build    The -p flag is currently supports OSX and Windows. On OSX, it bundles your binary into a .app file with the default icon. On Windows, it will generate the application resource files and compile it all into a \u0026lsquo;.exe\u0026rsquo;. When the -p flag is used, the packaging files are left available for editing. Any changes will be picked up by the next build (eg icon).\nUpdate  wails update\n This command does a check to see if the current version is the latest. If not, it will download and install the latest version. It is possible to also use it to install \u0026lsquo;prerelease\u0026rsquo; versions by using the -pre flag. If a specific version is required, then it supports a -version flag.\nExample: wails update -pre will update the latest prerelease version\nIssue  wails issue\n This command speeds up the process for submitting an issue to the Wails project. When you run the command, you will be asked to answer a couple of questions:\n Wails then determines some environmental details such as it\u0026rsquo;s own version, opens a browser and fills in the default issue template.\n Please note: you can edit the template as you feel fit before submitting.\nYou now have a good basis for your template. Running wails init will now give you your template as an option to install. When the project is generated using the template, it will create directories, copy non-template files then copy template files. Template files end in .template and will be treated as standard Go templates in which embedded codes are substituted with values in the Project Options.\n"
},
{
	"uri": "https://wails.app/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": " Development In this section we cover all aspects of Wails development and contribution guidelines.\nIssue Driven Development If there is something to add to the code, whether a bug or enhancement, a ticket should be opened so that it can be discussed. If the coding goes ahead, a new branch should be created from the develop branch with a reference to the ticket ID, eg: 64 - Support react\nCommit messages should follow the conventional commits format:\n tag[(scope)]: message     Tag Meaning     fix Bugfix   feat New Feature   docs Documentation update   BREAKING CHANGE API Change    Examples:\n fix: this is a fix for the project as a whole fix(cli): this is a fix for the cli docs: updated the contributors  Branch Workflow  Wails uses a gitflow-like approach to development Feature/Bugfix branches are created from the develop branch Once the work is complete, pull requests should be made against the develop branch As features are added, the develop branch is tagged with pre-release tags Releases are made weekly, so at the end of the weekly cycle, the latest features and bugfixes that were made will be merged to master and tagged with the next appropriate version.  Example:\n After release v0.14.0, a ticket (#63) is opened requesting react support This is worked on and a PR is made back to develop Once merged, develop is tagged with v0.14.1-pre A ticket (#64) is opened requesting ultralight support This is worked on and a PR is made back to develop Once merged, develop is tagged with v0.14.2-pre We reach the end of our week and merge v0.14.2-pre to master, tagging it as v0.15.0 Work continues on the devel branch   Tooling The Wails cli has developer tooling built in, but needs activating. To create a developer version, do the following:\ncd cmd/wails go install --tags=dev  This unlocks a wails dev command that has subcommands for development.\nCreating new project templates With a developer enabled cli, you can run wails dev newtemplate to create a new project template. You will be asked a number of questions regarding your template and as a result, a new directory will be created in \u0026lt;project-root\u0026gt;/cmd/templates.\nHere is an example run:\nWails v0.14.4-pre - Generating new project template ? Please enter the name of your template (eg: React/Webpack Basic): Mithril Basic ? Please enter a short description for the template (eg: React with Webpack 4): Mithril with Webpack 3 ? Please enter a long description: Mithril v2.0.0-rc.4 with Webpack 4 ? Please enter the name of the directory the frontend code resides (eg: frontend): frontend ? Please enter the install command (eg: npm install): npm install ? Please enter the build command (eg: npm run build): npm run build ? Please enter the serve command (eg: npm run serve): npm run serve ? Please enter the name of the directory to copy the wails bridge runtime (eg: src): src ? Please enter a directory name for the template: mithril-basic Created new template 'Mithril Basic' in directory '/Users/lea/Projects/wails/cmd/templates/mithril-basic'  This generates the following template.json:\n{ \u0026#34;name\u0026#34;: \u0026#34;Mithril Basic\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;shortdescription\u0026#34;: \u0026#34;Mithril with Webpack 3\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Mithril v2.0.0-rc.4 with Webpack 4\u0026#34;, \u0026#34;install\u0026#34;: \u0026#34;npm install\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;npm run build\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Duncan Disorderly \u0026lt;frostyjack@sesh.com\u0026gt;\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-05-20 20:16:30.394489 +1000 AEST m=+159.490635188\u0026#34;, \u0026#34;frontenddir\u0026#34;: \u0026#34;frontend\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;npm run serve\u0026#34;, \u0026#34;bridge\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;wailsdir\u0026#34;: \u0026#34;\u0026#34; } Note: The wailsdir key is currently unused but will be used in place of bridge in the near future\n"
},
{
	"uri": "https://wails.app/releases/",
	"title": "Releases",
	"tags": [],
	"description": "",
	"content": " Releases "
},
{
	"uri": "https://wails.app/",
	"title": "Wails",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://wails.app/about/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Wails has been designed to be make the gap between web technologies and Go as minimal as possible. The frontend is a Webview component, and you may develop your frontend code using any common Javascript framework you like, and seemlessly interact with your Go code from it. This is done through a shared IPC mechanism.\n IPC Overview The IPC mechanism operates across 2 runtimes - one in Javascript and the other in Go. They both provide a simple interface, removing the burden from the developer from needing to deal with the IPC mechanism directly.\n The runtimes share common components which the developer can interact with: Binding and Events.\n Binding A Wails application provides a single method that allows you to expose (bind) your Go code to the frontend. Using this method, you may bind an arbitrary function or a struct with exposed methods. At startup, Wails will analyse bound functions/methods and automatically provide the equivalent functions in Javascript. This allows you to call your bound Go code directly from Javascript.\n The Javascript wrapper functions deal with all of the complexity of calling the Go code. You simply call the function in Javascript and receive a promise back. The function to bind your Go code deals with all the complexity of binding. If the call to your Go code completes successfully, the result will be passed to the resolve function. If an error is returned, this will be passed to the reject function.\nEvents Wails provides a unified Events system similar to Javascript\u0026rsquo;s native events system. This means that any event that is sent from either Go or Javascript can be picked up by either side. Data may be passed along with any event. This allows you to do neat things like have background processes running in Go and notifying the frontend of any updates.\n "
},
{
	"uri": "https://wails.app/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://wails.app/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]